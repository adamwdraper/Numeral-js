/*
 * numeral.js format configuration
 * format : bytes
 * author : Adam Draper : https://github.com/adamwdraper
 */
import numeral from '../numeral';

var decimal = {
        base: 1000,
        suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
    },
    binary = {
        base: 1024,
        suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
    };

numeral.register('format', 'bytes', {
    regexps: {
        format: /([0\s]i?b)/,
        unformat: new RegExp('(' + decimal.suffixes.concat(binary.suffixes).join('|') + ')')
    },
    format(value, format, roundingFunction) {
        var output,
            bytes = numeral._.includes(format, 'ib') ? binary : decimal,
            suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '',
            power,
            min,
            max;

        // check for space before
        format = format.replace(/\s?i?b/, '');

        for (power = 0; power <= bytes.suffixes.length; power++) {
            min = Math.pow(bytes.base, power);
            max = Math.pow(bytes.base, power + 1);

            if (value === null || value === 0 || value >= min && value < max) {
                suffix += bytes.suffixes[power];

                if (min > 0) {
                    value = value / min;
                }

                break;
            }
        }

        output = numeral._.numberToFormat(value, format, roundingFunction);

        return output + suffix;
    },
    unformat(string) {
        var value = numeral._.stringToNumber(string),
            power,
            bytesMultiplier;

        if (value) {
            for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                if (numeral._.includes(string, decimal.suffixes[power])) {
                    bytesMultiplier = Math.pow(decimal.base, power);

                    break;
                }

                if (numeral._.includes(string, binary.suffixes[power])) {
                    bytesMultiplier = Math.pow(binary.base, power);

                    break;
                }
            }

            value *= (bytesMultiplier || 1);
        }

        return value;
    }
});
